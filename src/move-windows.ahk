#Requires AutoHotkey v2.0
#SingleInstance Force

; Version is injected at build time from package.json.
; This file is generated by the npm build script.
#Include "*i %A_ScriptDir%\version.generated.ahk"
global SCRIPT_VERSION := IsSet(SCRIPT_VERSION) ? SCRIPT_VERSION : "unknown"

try DllCall("user32\SetProcessDpiAwarenessContext", "ptr", -4) ; PER_MONITOR_AWARE_V2

global g_cyclePos := -1
global g_cycleSig := ""
global g_cycleOrder := []

; ---- Tray menu ----
; Right-click menu: version (disabled) + Exit. Left-click: no menu pop-up.
A_TrayMenu.Delete()
verLabel := "move-windows v" SCRIPT_VERSION
A_TrayMenu.Add(verLabel, (*) => 0)
A_TrayMenu.Disable(verLabel)
A_TrayMenu.Add() ; separator
A_TrayMenu.Add("Exit", (*) => ExitApp())
A_TrayMenu.ClickCount := 2

; Ctrl+Alt+F → Move all windows to PRIMARY monitor
^!f::MoveAllWindowsToPrimary()

; Ctrl+Alt+S → Move all windows to NEXT monitor (relative to primary)
; ^!s::MoveAllWindowsToSecondary()  ; Always move to next monitor after primary
^!s::MoveAllWindowsToNextMonitor()  ; Cycle through monitors

^!d:: {
    p := GetPrimaryMonitorIndex()
    MsgBox "AHK primary monitor index = " p
}

MoveAllWindowsToPrimary() {
    primary := GetPrimaryMonitorIndex()
    if !primary
        return
    MoveAllWindowsToMonitor(primary)
}

MoveAllWindowsToSecondary() {
    primary := GetPrimaryMonitorIndex()
    count   := MonitorGetCount()

    if (count < 2)
        return  ; nothing to do

    ; Pick "the other" monitor in a stable way
    ; If more than 2 monitors exist, this picks the nearest non-primary.
    target := FindBestSecondaryMonitor(primary)

    MoveAllWindowsToMonitor(target)
}

MoveAllWindowsToNextMonitor() {
    global g_cyclePos, g_cycleSig, g_cycleOrder

    order := GetMonitorOrderLR()
    sig := MonitorOrderSignature(order)

    ; Reset cycling if monitor topology changed (dock/undock, resolution changes, etc.)
    if (sig != g_cycleSig) {
        g_cycleSig := sig
        g_cycleOrder := order
        g_cyclePos := -1
    }

    count := g_cycleOrder.Length
    if (count < 2)
        return

    ; First press after reset: start from PRIMARY monitor in the order
    if (g_cyclePos = -1) {
        primary := GetPrimaryMonitorIndex()
        g_cyclePos := IndexOf(g_cycleOrder, primary)
        if (g_cyclePos = 0) ; should not happen, but safe
            g_cyclePos := 1
    }

    ; Next monitor (wrap around)
    g_cyclePos := (g_cyclePos >= count) ? 1 : (g_cyclePos + 1)

    targetMon := g_cycleOrder[g_cyclePos]
    MoveAllWindowsToMonitor(targetMon)
}

GetMonitorOrderLR() {
    mons := []
    Loop MonitorGetCount() {
        i := A_Index
        MonitorGet(i, &L, &T, &R, &B)
        mons.Push({ idx:i, L:L, T:T, R:R, B:B })
    }

    eps := 50

    ; insertion sort by (floor(L/eps), floor(T/eps))
    sorted := []
    for m in mons {
        keyL := Floor(m.L / eps)
        keyT := Floor(m.T / eps)

        inserted := false
        Loop sorted.Length {
            j := A_Index
            s := sorted[j]
            sKeyL := Floor(s.L / eps)
            sKeyT := Floor(s.T / eps)

            if (keyL < sKeyL) || (keyL = sKeyL && keyT < sKeyT) {
                sorted.InsertAt(j, m)
                inserted := true
                break
            }
        }
        if !inserted
            sorted.Push(m)
    }

    order := []
    for m in sorted
        order.Push(m.idx)
    return order
}

MonitorOrderSignature(order) {
    ; Create a signature that changes if monitor count/geometry changes
    parts := []
    parts.Push("n=" . order.Length)
    for idx in order {
        MonitorGet(idx, &L, &T, &R, &B)
        parts.Push(idx ":" L "," T "," R "," B)
    }
    return StrJoin(parts, "|")
}

IndexOf(arr, value) {
    for i, v in arr
        if (v = value)
            return i
    return 0
}

StrJoin(arr, sep) {
    out := ""
    for i, s in arr
        out .= (i=1 ? "" : sep) . s
    return out
}

FindBestSecondaryMonitor(primary) {
    MonitorGetWorkArea(primary, &pL, &pT, &pR, &pB)
    pCX := (pL + pR) / 2
    pCY := (pT + pB) / 2

    best := 0
    bestDist := 1e18

    Loop MonitorGetCount() {
        i := A_Index
        if (i = primary)
            continue

        MonitorGetWorkArea(i, &L, &T, &R, &B)
        cX := (L + R) / 2
        cY := (T + B) / 2
        dist := (cX - pCX)**2 + (cY - pCY)**2

        if (dist < bestDist) {
            bestDist := dist
            best := i
        }
    }
    return best
}

MoveAllWindowsToMonitor(targetMon) {
    MonitorGetWorkArea(targetMon, &tL, &tT, &tR, &tB)
    tW := tR - tL, tH := tB - tT

    for hwnd in WinGetList() {
        try {
            if !IsMovableTopLevelWindow(hwnd)
                continue

            if WindowIsOnMonitor(hwnd, targetMon)
                continue

            mm := WinGetMinMax("ahk_id " hwnd) ; -1=min, 0=normal, 1=max

            ; Remote Desktop exception: skip if minimized OR fullscreen
            if IsRemoteDesktopWindow(hwnd) {
                if (mm = -1)
                    continue
                if (mm != -1 && IsFullScreenOnItsMonitor(hwnd))
                    continue
            }

            ; Fullscreen exception for all apps (when not minimized)
            if (mm != -1 && IsFullScreenOnItsMonitor(hwnd))
                continue

            ; ---- Minimized: move restore-rect via WINDOWPLACEMENT (no restore) ----
            if (mm = -1) {
                wp := GetWindowPlacement(hwnd)
                if !wp
                    continue

                WP_GetNormalRect(wp, &x, &y, &r, &b)
                w := r - x, h := b - y
                if (w <= 0 || h <= 0)
                    continue

                srcMon := MonitorFromPoint(x + w/2, y + h/2)
                MonitorGetWorkArea(srcMon, &sL, &sT, &sR, &sB)
                sW := sR - sL, sH := sB - sT

                relX := (sW != 0) ? (x - sL) / sW : 0
                relY := (sH != 0) ? (y - sT) / sH : 0

                scale := Min(1.0, tW / w, tH / h)
                newW := Clamp(Round(w * scale), 300, tW)
                newH := Clamp(Round(h * scale), 200, tH)

                newX := Clamp(Round(tL + relX * tW), tL, tR - newW)
                newY := Clamp(Round(tT + relY * tH), tT, tB - newH)

                WP_SetNormalRect(wp, newX, newY, newX + newW, newY + newH)
                SW_SHOWMINIMIZED := 2
                WP_SetShowCmd(wp, SW_SHOWMINIMIZED)
                SetWindowPlacement(hwnd, wp)
                continue
            }

            ; ---- Non-minimized ----
            if (mm = 1)
                WinRestore("ahk_id " hwnd)

            WinGetPos(&x, &y, &w, &h, "ahk_id " hwnd)
            if (w <= 0 || h <= 0)
                continue

            dpiBefore := GetDpiForHwnd(hwnd)

            srcMon := MonitorFromPoint(x + w/2, y + h/2)
            MonitorGetWorkArea(srcMon, &sL, &sT, &sR, &sB)
            sW := sR - sL, sH := sB - sT

            relX := (sW != 0) ? (x - sL) / sW : 0
            relY := (sH != 0) ? (y - sT) / sH : 0

            ; Scale down if needed, never up
            scale := Min(1.0, tW / w, tH / h)
            intendedW := Clamp(Round(w * scale), 300, tW)
            intendedH := Clamp(Round(h * scale), 200, tH)

            intendedX := Clamp(Round(tL + relX * tW), tL, tR - intendedW)
            intendedY := Clamp(Round(tT + relY * tH), tT, tB - intendedH)

            WinMove(intendedX, intendedY, intendedW, intendedH, "ahk_id " hwnd)

            if !WindowIsOnMonitor(hwnd, targetMon)
                SetWindowPos(hwnd, intendedX, intendedY, intendedW, intendedH)

            ; ---- DPI-change driven settle ----
            dpiAfter := GetDpiForHwnd(hwnd)
            if (dpiAfter != dpiBefore) {
                Sleep 40
                WinGetPos(&x2, &y2, &w2, &h2, "ahk_id " hwnd)

                ; If app resized itself, snap back to intended size (if it fits)
                desiredW := intendedW
                desiredH := intendedH

                ; (safety: if intended doesn't fit for some reason, scale down)
                if (desiredW > tW || desiredH > tH) {
                    s2 := Min(1.0, tW / desiredW, tH / desiredH)
                    desiredW := Clamp(Round(desiredW * s2), 300, tW)
                    desiredH := Clamp(Round(desiredH * s2), 200, tH)
                }

                finalX := Clamp(x2, tL, tR - desiredW)
                finalY := Clamp(y2, tT, tB - desiredH)

                if (w2 != desiredW || h2 != desiredH || x2 != finalX || y2 != finalY) {
                    WinMove(finalX, finalY, desiredW, desiredH, "ahk_id " hwnd)
                    if !WindowIsOnMonitor(hwnd, targetMon)
                        SetWindowPos(hwnd, finalX, finalY, desiredW, desiredH)
                }
            }

        } catch {
            ; keep going
        }
    }
}

GetDpiForHwnd(hwnd) {
    ; Win10+; fallback to 96 if unavailable
    try {
        return DllCall("user32\GetDpiForWindow", "ptr", hwnd, "uint")
    } catch {
        return 96
    }
}

IsFullScreenOnItsMonitor(hwnd) {
    ; Treat as fullscreen if it matches the full monitor bounds (not work area),
    ; within a small tolerance for borders/DPI quirks.
    WinGetPos(&x, &y, &w, &h, "ahk_id " hwnd)

    mon := MonitorFromPoint(x + w/2, y + h/2)
    MonitorGet(mon, &L, &T, &R, &B)
    mW := R - L
    mH := B - T

    tol := 2
    return (Abs(x - L) <= tol
        && Abs(y - T) <= tol
        && Abs(w - mW) <= tol
        && Abs(h - mH) <= tol)
}

GetPrimaryMonitorIndex() {
    primaryRect := GetPrimaryMonitorRect()
    if !primaryRect
        return 1

    ; Map rect -> AHK monitor index
    Loop MonitorGetCount() {
        i := A_Index
        MonitorGet(i, &l, &t, &r, &b)
        if (l = primaryRect.L && t = primaryRect.T && r = primaryRect.R && b = primaryRect.B)
            return i
    }

    ; Fallback: if exact match fails (rare DPI/driver weirdness), match by center point
    cx := Floor((primaryRect.L + primaryRect.R) / 2)
    cy := Floor((primaryRect.T + primaryRect.B) / 2)
    return MonitorFromPoint(cx, cy)
}

GetPrimaryMonitorRect() {
    ; Returns an object {L,T,R,B} for the MONITORINFOF_PRIMARY monitor
    ; Uses EnumDisplayMonitors + GetMonitorInfoW (authoritative).
    cb := CallbackCreate(EnumMonProc, "F")
    DllCall("user32\EnumDisplayMonitors", "ptr", 0, "ptr", 0, "ptr", cb, "ptr", 0)
    CallbackFree(cb)
    return EnumMonProc_PrimaryRect  ; global set by callback
}

; Internal global used by callback
global EnumMonProc_PrimaryRect := 0

EnumMonProc(hMon, hdc, lprc, dwData) {
    global EnumMonProc_PrimaryRect

    ; MONITORINFO = 40 bytes
    mi := Buffer(40, 0)
    NumPut("uint", 40, mi, 0)

    if !DllCall("user32\GetMonitorInfoW", "ptr", hMon, "ptr", mi)
        return true  ; continue

    flags := NumGet(mi, 36, "uint") ; dwFlags
    if (flags & 0x1) {              ; MONITORINFOF_PRIMARY
        L := NumGet(mi, 4,  "int")
        T := NumGet(mi, 8,  "int")
        R := NumGet(mi, 12, "int")
        B := NumGet(mi, 16, "int")
        EnumMonProc_PrimaryRect := { L:L, T:T, R:R, B:B }
        return false ; stop enumeration
    }
    return true ; continue
}

IsPrimaryHMONITOR(hMon) {
    ; MONITORINFO size differs between basic and EX; use MONITORINFOEX (104 bytes on x64 typically)
    ; We'll allocate a generous buffer and read dwFlags.
    bufSize := 200
    mi := Buffer(bufSize, 0)
    NumPut("uint", bufSize, mi, 0)
    if !DllCall("user32\GetMonitorInfoW", "ptr", hMon, "ptr", mi)
        return false
    dwFlags := NumGet(mi, 40, "uint") ; offset of dwFlags after rcMonitor(16) + rcWork(16) + cbSize(4) = 36? Actually cbSize at 0, then rcMonitor at 4..19, rcWork 20..35, dwFlags at 36.
    ; Safer:
    dwFlags := NumGet(mi, 36, "uint")
    return (dwFlags & 1) != 0
}

RectPtr(l,t,r,b) {
    rect := Buffer(16, 0)
    NumPut("int", l, rect, 0)
    NumPut("int", t, rect, 4)
    NumPut("int", r, rect, 8)
    NumPut("int", b, rect, 12)
    return rect.ptr
}

IsMovableTopLevelWindow(hwnd) {
    if !WinExist("ahk_id " hwnd)
        return false
    title := WinGetTitle("ahk_id " hwnd)
    if (title = "" || title = "Program Manager")
        return false

    exStyle := WinGetExStyle("ahk_id " hwnd)
    WS_EX_TOOLWINDOW := 0x80
    if (exStyle & WS_EX_TOOLWINDOW)
        return false

    if IsCloaked(hwnd)
        return false

    return true
}

IsCloaked(hwnd) {
    cloaked := 0
    DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hwnd, "int", 14, "int*", &cloaked, "int", 4)
    return cloaked != 0
}

MonitorFromPoint(x, y) {
    best := 1, bestDist := 1e18
    Loop MonitorGetCount() {
        i := A_Index
        MonitorGetWorkArea(i, &L, &T, &R, &B)
        dx := (x < L) ? (L - x) : (x > R) ? (x - R) : 0
        dy := (y < T) ? (T - y) : (y > B) ? (y - B) : 0
        dist := dx*dx + dy*dy
        if (dist < bestDist)
            bestDist := dist, best := i
    }
    return best
}

WindowIsOnMonitor(hwnd, mon) {
    WinGetPos(&x, &y, &w, &h, "ahk_id " hwnd)
    return MonitorFromPoint(x + w/2, y + h/2) = mon
}

Clamp(v, lo, hi) => (v < lo) ? lo : (v > hi) ? hi : v

SetWindowPos(hwnd, x, y, w, h) {
    SWP_NOZORDER := 0x0004
    SWP_NOACTIVATE := 0x0010
    DllCall("user32\SetWindowPos"
        , "ptr", hwnd, "ptr", 0
        , "int", x, "int", y, "int", w, "int", h
        , "uint", SWP_NOZORDER | SWP_NOACTIVATE)
}

IsRemoteDesktopWindow(hwnd) {
    try {
        return WinGetProcessName("ahk_id " hwnd) = "mstsc.exe"
    } catch {
        return false
    }
}

; WINDOWPLACEMENT helpers (AHK v2)
GetWindowPlacement(hwnd) {
    ; struct WINDOWPLACEMENT:
    ; UINT length;
    ; UINT flags;
    ; UINT showCmd;
    ; POINT ptMinPosition;
    ; POINT ptMaxPosition;
    ; RECT  rcNormalPosition;
    ; -> 44 bytes on Win32, 48 bytes on Win64? (RECT uses 4 ints either way)
    ; Use 44 works reliably for Get/Set on both in practice if packed, but we'll be safe with 48.
    wp := Buffer(48, 0)
    NumPut("uint", wp.Size, wp, 0)
    if !DllCall("user32\GetWindowPlacement", "ptr", hwnd, "ptr", wp)
        return 0
    return wp
}

SetWindowPlacement(hwnd, wp) {
    return DllCall("user32\SetWindowPlacement", "ptr", hwnd, "ptr", wp)
}

WP_GetShowCmd(wp) => NumGet(wp, 8, "uint")
WP_SetShowCmd(wp, cmd) => NumPut("uint", cmd, wp, 8)

WP_GetNormalRect(wp, &L, &T, &R, &B) {
    ; rcNormalPosition starts at offset 28 (length=4, flags=4, showCmd=4, ptMin=8, ptMax=8 => 28)
    L := NumGet(wp, 28, "int")
    T := NumGet(wp, 32, "int")
    R := NumGet(wp, 36, "int")
    B := NumGet(wp, 40, "int")
}

WP_SetNormalRect(wp, L, T, R, B) {
    NumPut("int", L, wp, 28)
    NumPut("int", T, wp, 32)
    NumPut("int", R, wp, 36)
    NumPut("int", B, wp, 40)
}
